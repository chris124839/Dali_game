<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Dali Puzzle – Free Online Puzzle Game</title>
<meta name="description" content="Play the Dali Puzzle game online for free. A fun visual puzzle challenge." />
<script src="https://cdn.tailwindcss.com"></script>
<style>
:root{
  --board-bg:#ffffff;      /* default white board background */
  --point-size:20px;
  --p1-color:#ff0000;      /* default player 1 color */
  --p2-color:#00aeff;      /* default player 2 color */
  --control-bg:#071a2b;
  --muted:#9fb0c8;
  --coin-border: rgba(0,0,0,0.85);
  --last-pulse: rgba(40,140,255,0.85); /* blue pulse color */
}

/* Page layout */
body{
  font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;
  background:#071026;
  color:#e6eef8;
  display:flex;
  justify-content:center;
  padding:16px;
  margin:0;
  min-height:100vh;
}
.container{width:100%;max-width:980px;}
.card{
  background:linear-gradient(180deg,#071026 0%, #091426 100%);
  border-radius:12px;
  padding:18px;
  box-shadow:0 12px 30px rgba(0,0,0,.6);
}

/* header */
.header-row{display:flex; justify-content:space-between; align-items:center; gap:8px; margin-bottom:8px;}
.small-muted{ color:var(--muted); font-size:13px; }

/* Controls area */
.controls{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:12px;}
.control{background:var(--control-bg);padding:8px;border-radius:8px;display:flex;align-items:center;gap:8px;font-size:14px;}
.control label{color:var(--muted); font-size:13px;}

/* Compact mobile options toggler */
#optionsToggle { display:none; background:transparent; border:none; color:var(--muted); font-size:15px; padding:8px; border-radius:8px; }
@media (max-width:720px){
  .controls { display:none; /* hidden by default on mobile - toggled by button */ }
  #optionsToggle { display:inline-flex; align-items:center; gap:8px; }
}

/* BOARD */
#board{
  width:100%;
  max-width:660px;
  padding-top:100%;
  position:relative;
  background:var(--board-bg);
  border-radius:0px; /* sharp board container corners */
  margin:8px auto;
  box-shadow:inset 0 6px 24px rgba(0,0,0,.6);
  overflow:hidden;
}

/* SVG board lines - sharp corners (rx=0 on rects) */
#board-svg{position:absolute; top:0; left:0; width:100%; height:100%; stroke:#9fb0c8; stroke-width:0.9; fill:none; pointer-events:none;}

/* POINTS (coins) */
.point{
  width:var(--point-size);
  height:var(--point-size);
  background:rgba(255,255,255,0.06);
  border:2px solid var(--coin-border);
  position:absolute;
  transform:translate(-50%,-50%);
  display:flex;
  align-items:center;
  justify-content:center;
  border-radius:50%;
  transition:transform .18s, box-shadow .18s, background-color .18s, top .25s, left .25s;
  cursor:pointer;
  user-select:none;
}
.point.square{ border-radius:4px; }   /* slightly rounded squares */
.point.hex { clip-path: polygon(25% 6.7%, 75% 6.7%, 100% 50%, 75% 93.3%, 25% 93.3%, 0% 50%); border-radius:0; }
.point.diamond{ border-radius:3px; transform-origin:50% 50%; }

/* hover / default styles */
.point:hover:not(.p1):not(.p2) { transform: translate(-50%,-50%) scale(1.08); background: rgba(255,255,255,0.16); box-shadow:0 0 8px rgba(255,255,255,0.06); }

.point.p1 { background:var(--p1-color); border-color:var(--coin-border); box-shadow:0 0 8px rgba(255,255,255,0.12); }
.point.p2 { background:var(--p2-color); border-color:var(--coin-border); box-shadow:0 0 8px rgba(0,0,0,0.4); }

.point.selected{ box-shadow:0 0 14px 4px #f6e05e; border:2px solid #f6e05e; transform:translate(-50%,-50%) scale(1.18); }
.point.dali-formed{ background:#48bb78 !important; border-color:#48bb78 !important; box-shadow:0 0 18px 6px #48bb78 !important; animation:pulse 1s infinite alternate; }

@keyframes pulse { from{opacity:1} to{opacity:.75} }

/* placement animation */
@keyframes pop { 0% { transform: translate(-50%,-50%) scale(.2) } 60% { transform: translate(-50%,-50%) scale(1.12) } 100% { transform: translate(-50%,-50%) scale(1) } }
.point.pop { animation: pop .32s ease forwards; }

/* last move pulse (Option B) — blue pulse */
@keyframes lastMovePulse {
  0% { transform: translate(-50%,-50%) scale(1); box-shadow: 0 0 0 0 rgba(40,140,255,0.9); }
  40% { transform: translate(-50%,-50%) scale(1.18); box-shadow: 0 0 18px 8px rgba(40,140,255,0.35); }
  100% { transform: translate(-50%,-50%) scale(1); box-shadow: 0 0 0 0 rgba(40,140,255,0); }
}
.point.last-move { animation: lastMovePulse 0.8s ease forwards; }

/* Responsive tweaks */
.flex-row { display:flex; gap:8px; align-items:center; }
@media (max-width:720px){
  .flex-row{flex-direction:column; align-items:flex-start;}
  #board{max-width:100%;}
}

/* Positioning of the 24 points */
[data-id="0"] { top: 5%; left: 5%; }
[data-id="1"] { top: 5%; left: 50%; }
[data-id="2"] { top: 5%; left: 95%; }
[data-id="3"] { top: 50%; left: 5%; }
[data-id="4"] { top: 50%; left: 95%; }
[data-id="5"] { top: 95%; left: 5%; }
[data-id="6"] { top: 95%; left: 50%; }
[data-id="7"] { top: 95%; left: 95%; }
[data-id="8"] { top: 20%; left: 20%; }
[data-id="9"] { top: 20%; left: 50%; }
[data-id="10"] { top: 20%; left: 80%; }
[data-id="11"] { top: 50%; left: 20%; }
[data-id="12"] { top: 50%; left: 80%; }
[data-id="13"] { top: 80%; left: 20%; }
[data-id="14"] { top: 80%; left: 50%; }
[data-id="15"] { top: 80%; left: 80%; }
[data-id="16"] { top: 35%; left: 35%; }
[data-id="17"] { top: 35%; left: 50%; }
[data-id="18"] { top: 35%; left: 65%; }
[data-id="19"] { top: 50%; left: 35%; }
[data-id="20"] { top: 50%; left: 65%; }
[data-id="21"] { top: 65%; left: 35%; }
[data-id="22"] { top: 65%; left: 50%; }
[data-id="23"] { top: 65%; left: 65%; }

/* Winner banner overlay */
#winnerBanner {
  position:absolute;
  left:50%;
  top:50%;
  transform:translate(-50%,-50%);
  background:linear-gradient(90deg, rgba(2,6,23,0.98), rgba(3,15,40,0.98));
  color:white;
  padding:20px;
  border-radius:12px;
  box-shadow:0 12px 30px rgba(0,0,0,0.6);
  display:none;
  z-index:40;
  width:90%;
  max-width:520px;
  text-align:center;
}
#winnerBanner h2 { font-size:20px; margin:0 0 10px 0; }
#winnerBanner button { padding:10px 14px; border-radius:8px; border:0; cursor:pointer; font-weight:600; }

/* small utility */
.theme-row { display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
.theme-btn { padding:6px 8px; border-radius:8px; border:1px solid rgba(255,255,255,0.06); cursor:pointer; font-size:13px; background:transparent; color:var(--muted); }
.theme-btn.active { box-shadow:0 6px 18px rgba(0,0,0,0.4); border-color:rgba(255,255,255,0.12); color:white; }
.option-group { display:flex; gap:8px; align-items:center; }

/* download preview button style (small inside controls if needed) */
#downloadPreview { padding:6px 10px; background:#2563eb; color:white; border-radius:8px; border:0; cursor:pointer; font-weight:600; }

/* small notes */
.note-small{ font-size:12px; color:var(--muted); margin-top:6px; }

</style>
</head>
<body>
<div class="container">
  <div class="card">

    <div class="header-row">
      <div>
        <h1 class="text-lg font-semibold" style="margin:0;">Dali Strategy — Puzzle Game</h1>
        <div class="small-muted">Play vs human or AI • Choose theme & difficulty</div>
      </div>

      <!-- Mobile options toggle (hidden on desktop) -->
      <div style="display:flex;align-items:center;gap:8px;">
        <button id="optionsToggle">Options ▾</button>
      </div>
    </div>

    <!-- CONTROLS -->
    <div class="controls" id="controlsPanel">

      <div class="control">
        <label>Mode</label>
        <select id="modeSelect" class="ml-1 bg-transparent outline-none" title="Choose mode">
          <option value="human-human">Human vs Human</option>
          <option value="human-computer">Human vs Computer</option>
        </select>
      </div>

      <div class="control">
        <label>Difficulty</label>
        <select id="difficultySelect" class="ml-1 bg-transparent outline-none" title="AI difficulty">
          <option value="easy">Easy</option>
          <option value="medium" selected>Medium</option>
          <option value="hard">Hard</option>
        </select>
      </div>

      <div class="control" style="flex-direction:column;min-width:140px;">
        <label>Board color</label>
        <div class="theme-row" style="margin-top:6px;">
          <button id="boardWhite" class="theme-btn board-theme active" data-color="#ffffff">White</button>
          <button class="theme-btn board-theme" data-color="#f7ecd0">Wood</button>
          <button class="theme-btn board-theme" data-color="#263244">Dark</button>
          <button class="theme-btn board-theme" data-color="#e6f2ff">Blue</button>
        </div>
      </div>

      <div class="control" style="flex-direction:column;min-width:160px;">
        <label>Player colors (presets)</label>
        <div class="theme-row" style="margin-top:6px;">
          <button class="theme-btn player-theme active" data-p1="#ff0000" data-p2="#00aeff">Red / Blue</button>
          <button class="theme-btn player-theme" data-p1="#00c853" data-p2="#ff9100">Green / Orange</button>
          <button class="theme-btn player-theme" data-p1="#ff4d4d" data-p2="#222222">Red / Black</button>
          <button class="theme-btn player-theme" data-p1="#7c4dff" data-p2="#ffd600">Purple / Yellow</button>
        </div>
        <div class="note-small">Or choose custom colors below</div>
      </div>

      <div class="control" style="flex-direction:column;min-width:150px;">
        <label>Custom player colors</label>
        <div style="display:flex;gap:8px;align-items:center;margin-top:6px;">
          <input id="p1Color" type="color" value="#ff0000" title="Player 1 color" />
          <input id="p2Color" type="color" value="#00aeff" title="Player 2 color" />
        </div>
      </div>

      <div class="control" style="flex-direction:column;min-width:140px;">
        <label>Coin shape</label>
        <select id="coinShape" class="ml-1 bg-transparent outline-none" style="margin-top:6px;">
          <option value="circle" selected>Circle</option>
          <option value="square">Square</option>
          <option value="hex">Hexagon</option>
          <option value="diamond">Diamond</option>
        </select>
      </div>

      <div class="control" style="display:flex;align-items:center;gap:8px;">
        <!-- New Game button (replaces old restart) -->
        <button id="newGameBtn" class="px-3 py-2 bg-emerald-600 rounded text-white font-semibold">New Game</button>
        <button id="downloadPreview" title="Download preview.png">Download Preview (PNG)</button>
      </div>

    </div> <!-- controls -->

    <!-- STATUS -->
    <h2 id="status-message" class="p-2 bg-[#082033] rounded mb-3 small-muted">Loading...</h2>

    <!-- BOARD -->
    <div id="board" aria-hidden="false">
      <svg id="board-svg" viewBox="0 0 100 100" preserveAspectRatio="none" aria-hidden="true">
        <!-- sharp corners: rx="0" -->
        <rect x="5" y="5" width="90" height="90" rx="0"/>
        <rect x="20" y="20" width="60" height="60" rx="0"/>
        <rect x="35" y="35" width="30" height="30" rx="0"/>
        <line x1="50" y1="5" x2="50" y2="35"/>
        <line x1="95" y1="50" x2="65" y2="50"/>
        <line x1="50" y1="95" x2="50" y2="65"/>
        <line x1="5" y1="50" x2="35" y2="50"/>
      </svg>

      <!-- overlay winner banner (hidden until win) -->
      <div id="winnerBanner" role="dialog" aria-live="assertive">
        <h2 id="winnerText">Player X Wins!</h2>
        <div style="margin-top:8px;">
          <button id="bannerNewGame" style="background:#10b981;color:white;">New Game</button>
          <button id="bannerClose" style="margin-left:10px;background:transparent;border:1px solid rgba(255,255,255,0.08);color:white;">Close</button>
        </div>
      </div>

      <!-- 24 points -->
      <div class="point circle" data-id="0"></div>
      <div class="point circle" data-id="1"></div>
      <div class="point circle" data-id="2"></div>
      <div class="point circle" data-id="3"></div>
      <div class="point circle" data-id="4"></div>
      <div class="point circle" data-id="5"></div>
      <div class="point circle" data-id="6"></div>
      <div class="point circle" data-id="7"></div>
      <div class="point circle" data-id="8"></div>
      <div class="point circle" data-id="9"></div>
      <div class="point circle" data-id="10"></div>
      <div class="point circle" data-id="11"></div>
      <div class="point circle" data-id="12"></div>
      <div class="point circle" data-id="13"></div>
      <div class="point circle" data-id="14"></div>
      <div class="point circle" data-id="15"></div>
      <div class="point circle" data-id="16"></div>
      <div class="point circle" data-id="17"></div>
      <div class="point circle" data-id="18"></div>
      <div class="point circle" data-id="19"></div>
      <div class="point circle" data-id="20"></div>
      <div class="point circle" data-id="21"></div>
      <div class="point circle" data-id="22"></div>
      <div class="point circle" data-id="23"></div>

    </div> <!-- board -->

    <div class="flex-row mt-4 gap-4">
      <div class="w-full bg-[#062033] p-3 rounded">
        <div class="small-muted">Player 1 pieces on board</div>
        <div id="p1Count" class="text-2xl font-bold">11</div>
      </div>
      <div class="w-full bg-[#062033] p-3 rounded">
        <div class="small-muted">Player 2 pieces on board</div>
        <div id="p2Count" class="text-2xl font-bold">11</div>
      </div>
    </div>

  </div> <!-- card -->
</div> <!-- container -->

<script>
/* =========================
   Board & Dalis config
   ========================= */
const boardMap = [
  [1,3],[0,2,9],[1,4],[0,5,11],[2,7,12],[3,6],[5,7,14],[4,6],
  [9,11],[1,8,10,17],[9,12],[3,8,13,19],[4,10,15,20],[11,14],[6,13,15,22],[12,14],
  [17,19],[9,16,18],[17,20],[11,16,21],[12,18,23],[19,22],[14,21,23],[20,22]
];

const dalis = [
  [0,1,2],[5,6,7],[8,9,10],[13,14,15],[16,17,18],[21,22,23],
  [0,3,5],[2,4,7],[8,11,13],[10,12,15],[16,19,21],[18,20,23],
  [1,9,17],[3,11,19],[6,14,22],[4,12,20]
];

/* =========================
   DOM references
   ========================= */
const statusText = document.getElementById('status-message');
const points = Array.from(document.querySelectorAll('.point'));
const p1CountEl = document.getElementById('p1Count');
const p2CountEl = document.getElementById('p2Count');
const boardEl = document.getElementById('board');

const modeSelect = document.getElementById('modeSelect');
const difficultySelect = document.getElementById('difficultySelect');
const controlsPanel = document.getElementById('controlsPanel');
const optionsToggle = document.getElementById('optionsToggle');

const newGameBtn = document.getElementById('newGameBtn');
const bannerNewGame = document.getElementById('bannerNewGame');
const bannerClose = document.getElementById('bannerClose');
const winnerBanner = document.getElementById('winnerBanner');
const winnerText = document.getElementById('winnerText');

const downloadPreviewBtn = document.getElementById('downloadPreview');

/* Theme controls */
const boardThemeBtns = Array.from(document.querySelectorAll('.board-theme'));
const playerThemeBtns = Array.from(document.querySelectorAll('.player-theme'));
const p1ColorInput = document.getElementById('p1Color');
const p2ColorInput = document.getElementById('p2Color');
const coinShapeEl = document.getElementById('coinShape');

/* =========================
   Game state
   ========================= */
let boardState = new Array(24).fill(0); // 0 empty, 1 p1, 2 p2
let currentPlayer = 1;
let gamePhase = 'placing'; // 'placing','moving','removing','ask_give'
let piecesToPlace = 22;
let player1PieceCount = 11;
let player2PieceCount = 11;
let selectedPiece = null;
let formedDali = null;
let giveRequester = null;
let giveGiver = null;
let lastMoveId = null; // for last-move indicator

// AI settings
let humanPlays = {1:true, 2:true}; // default both humans
let aiPlaysAs = null; // if ai plays as player 2 then aiPlaysAs=2

/* =========================
   Sound (Web Audio API)
   ========================= */
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
function beep(freq=440, duration=0.12, type='sine', gain=0.06){
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = type; o.frequency.value = freq;
  g.gain.value = gain;
  o.connect(g); g.connect(audioCtx.destination);
  o.start(); o.stop(audioCtx.currentTime + duration);
}
function playSound(name){
  if (audioCtx.state === 'suspended') audioCtx.resume().catch(()=>{});
  if (name==='place'){ beep(780,0.12,'sine',0.07); }
  else if (name==='select'){ beep(520,0.08,'triangle',0.04); }
  else if (name==='dali'){ beep(1020,0.16,'sine',0.12); beep(760,0.12,'sine',0.08); }
  else if (name==='error'){ beep(240,0.12,'square',0.10); }
  else if (name==='win'){ beep(1200,0.16,'sine',0.12); beep(1500,0.18,'sine',0.14); }
}

/* =========================
   Helper functions
   ========================= */
function isAdjacent(a,b){ return boardMap[a].includes(b); }

function isPieceInDali(pointId, player){
  for (const d of dalis){
    if (d.includes(pointId)){
      if (boardState[d[0]]===player && boardState[d[1]]===player && boardState[d[2]]===player) return true;
    }
  }
  return false;
}

function checkAllPiecesInDalis(opponent){
  const oppPieces = boardState.map((v,i)=>v===opponent?i:-1).filter(i=>i!==-1);
  if (oppPieces.length===0) return true;
  for (const id of oppPieces) if (!isPieceInDali(id,opponent)) return false;
  return true;
}

function checkDali(pointId){
  removeDaliHighlight();
  for (const d of dalis.filter(l => l.includes(pointId))){
    if (boardState[d[0]]===currentPlayer && boardState[d[1]]===currentPlayer && boardState[d[2]]===currentPlayer){
      formedDali = d.slice();
      highlightDali();
      return true;
    }
  }
  formedDali = null;
  return false;
}
function highlightDali(){
  if (!formedDali) return;
  formedDali.forEach(id=>points[id]?.classList.add('dali-formed'));
  playSound('dali');
}
function removeDaliHighlight(){
  if (!formedDali) return;
  formedDali.forEach(id=>points[id]?.classList.remove('dali-formed'));
  formedDali = null;
}

/* compute contrasting coin border based on board background */
function computeContrastColor(hex) {
  // hex like #rrggbb
  if (!hex) return 'rgba(0,0,0,0.85)';
  const h = hex.replace('#','');
  const r = parseInt(h.substring(0,2),16);
  const g = parseInt(h.substring(2,4),16);
  const b = parseInt(h.substring(4,6),16);
  // luminance
  const L = (0.299*r + 0.587*g + 0.114*b)/255;
  // if background is light -> use dark border, else white-ish border
  return L > 0.6 ? 'rgba(0,0,0,0.85)' : 'rgba(255,255,255,0.92)';
}

/* place piece visually with pop and last-move pulse */
function placePiece(id){
  boardState[id] = currentPlayer;
  piecesToPlace--;
  const pt = points[id];
  pt.classList.add(currentPlayer===1?'p1':'p2');
  pt.classList.remove('selected','dali-formed');
  // set solid border for visibility
  pt.style.borderColor = getComputedStyle(document.documentElement).getPropertyValue('--coin-border').trim();
  // pop animation
  pt.classList.remove('pop');
  void pt.offsetWidth;
  pt.classList.add('pop');
  playSound('place');

  // mark last move: remove previous last-move marker if present
  if (lastMoveId !== null && points[lastMoveId]) points[lastMoveId].classList.remove('last-move');
  lastMoveId = id;
  // apply pulse class to this point; it will animate once (CSS forwards)
  pt.classList.remove('last-move');
  void pt.offsetWidth;
  pt.classList.add('last-move');
  // remove the class after animation to keep DOM clean
  pt.addEventListener('animationend', function _onEnd(ev){
    if (ev.animationName === 'lastMovePulse') {
      pt.classList.remove('last-move');
      pt.removeEventListener('animationend', _onEnd);
    }
  });
}

function removePiece(id){
  const owner = boardState[id];
  boardState[id]=0;
  if (owner===1) player1PieceCount--;
  else if (owner===2) player2PieceCount--;
  const pt = points[id];
  pt.classList.remove('p1','p2','selected','dali-formed','last-move','pop');
  pt.style.borderColor = getComputedStyle(document.documentElement).getPropertyValue('--coin-border').trim();
}

function switchPlayer(){ currentPlayer = (currentPlayer===1?2:1); }

function checkBlocked(){
  const player=currentPlayer;
  const playerPieces = boardState.map((v,i)=>v===player?i:-1).filter(i=>i!==-1);
  if (playerPieces.length<=2) return false;
  for (const piece of playerPieces){
    for (const n of boardMap[piece]) if (boardState[n]===0) return false;
  }
  const winner = (player===1?2:1);
  endGame(winner,'blocked');
  return true;
}

function checkWin(){
  const opponentCount = (currentPlayer===1?player2PieceCount:player1PieceCount);
  if (opponentCount<=2){ endGame(currentPlayer,'elimination'); return true; }
  return false;
}

/* END GAME: show banner overlay and disable board clicks */
function endGame(winner, reason){
  let msg = `Player ${winner} wins!`;
  if (reason === 'elimination') msg += " (reduced opponent to 2 pieces)";
  else if (reason === 'blocked') msg += " (opponent blocked)";
  winnerText.textContent = msg;
  winnerBanner.style.display = 'block';
  points.forEach(pt => pt.removeEventListener('click', handlePointClick));
  playSound('win');
}

/* =========================
   Phase handlers
   ========================= */
function handlePointClick(e){
  if (!e.target) return;
  const id = parseInt(e.target.dataset.id,10);

  // when in ask_give phase, only the giveGiver may click
  if (gamePhase==='ask_give'){
    if (boardState[id] === giveGiver && giveGiver!==null){
      removePiece(id);
      removeDaliHighlight();
      if (checkWin()) return;
      gamePhase = (piecesToPlace===0)?'moving':'placing';
      switchPlayer();
      updateUI();
      maybeTriggerAI();
      return;
    } else {
      statusText.textContent = `Player ${giveGiver}: Choose one of your pieces to GIVE.`;
      playSound('error');
      return;
    }
  }

  if (gamePhase==='placing'){
    if (boardState[id]!==0){ statusText.textContent = `Player ${currentPlayer}: Spot taken.`; playSound('error'); return; }
    placePiece(id);
    if (checkDali(id)){ gamePhase='removing'; updateUI(); maybeTriggerAI(); return; }
    switchPlayer();
    if (piecesToPlace===0) gamePhase='moving';
    updateUI();
    maybeTriggerAI();
    return;
  }

  if (gamePhase==='moving'){
    const ptEl = points[id];
    if (selectedPiece===null){
      if (boardState[id]===currentPlayer){
        selectedPiece = id; ptEl.classList.add('selected'); statusText.textContent = `Player ${currentPlayer}: Select adjacent empty spot.`; playSound('select');
      } else { statusText.textContent = `Player ${currentPlayer}: select your piece first.`; playSound('error'); }
      return;
    } else {
      if (id===selectedPiece){
        points[selectedPiece].classList.remove('selected'); selectedPiece=null; updateUI(); return;
      }
      if (boardState[id]===0 && isAdjacent(selectedPiece, id)){
        boardState[id] = currentPlayer; boardState[selectedPiece]=0;
        const old = points[selectedPiece];
        old.classList.remove('p1','p2','selected');
        points[id].classList.add(currentPlayer===1?'p1':'p2');
        playSound('place');
        selectedPiece=null;
        // last move update: animate
        if (lastMoveId !== null && points[lastMoveId]) points[lastMoveId].classList.remove('last-move');
        lastMoveId = id;
        points[id].classList.remove('last-move');
        void points[id].offsetWidth;
        points[id].classList.add('last-move');
        points[id].addEventListener('animationend', function _onEnd(ev){
          if (ev.animationName === 'lastMovePulse') {
            points[id].classList.remove('last-move');
            points[id].removeEventListener('animationend', _onEnd);
          }
        });

        if (checkDali(id)){ gamePhase='removing'; updateUI(); maybeTriggerAI(); return; }
        removeDaliHighlight();
        switchPlayer();
        if (checkBlocked()) return;
        updateUI();
        maybeTriggerAI();
        return;
      } else {
        statusText.textContent = `Player ${currentPlayer}: Invalid move. Choose adjacent empty spot.`; playSound('error'); return;
      }
    }
  }

  if (gamePhase==='removing'){
    const opponent = currentPlayer===1?2:1;
    if (boardState[id]!==opponent){ statusText.textContent=`Player ${currentPlayer}: Remove an opponent piece.`; playSound('error'); return; }
    const isD = isPieceInDali(id,opponent);
    const allIn = checkAllPiecesInDalis(opponent);
    if (isD && !allIn){ statusText.textContent=`Cannot remove piece in a Dali.`; playSound('error'); return; }
    if (allIn){
      giveRequester = currentPlayer; giveGiver = opponent; gamePhase='ask_give';
      statusText.textContent = `All Player ${opponent}'s pieces are in Dalis. Player ${opponent}: You must GIVE one piece (click it).`;
      playSound('error');
      if (!humanPlays[giveGiver]) setTimeout(()=>aiGivePiece(giveGiver),650);
      return;
    }
    // normal removal
    removePiece(id); removeDaliHighlight(); playSound('select');
    if (checkWin()) return;
    gamePhase = (piecesToPlace===0)?'moving':'placing';
    switchPlayer();
    updateUI();
    maybeTriggerAI();
  }
}

/* =========================
   AI logic (same as earlier)
   ========================= */
function emptySpots(){ return boardState.map((v,i)=>v===0?i:-1).filter(i=>i!==-1); }
function wouldCreateDaliIfPlaced(player, spot){
  const orig = boardState[spot];
  boardState[spot] = player;
  let formed=false;
  for (const d of dalis.filter(l=>l.includes(spot))){
    if (boardState[d[0]]===player && boardState[d[1]]===player && boardState[d[2]]===player) { formed=true; break; }
  }
  boardState[spot] = orig;
  return formed;
}
function aiChoosePlacement(player, difficulty){
  const opponent = player===1?2:1;
  const empties = emptySpots();
  if (empties.length===0) return null;
  if (difficulty==='easy'){ return empties[Math.floor(Math.random()*empties.length)]; }
  for (const s of empties) if (wouldCreateDaliIfPlaced(player,s)) return s;
  for (const s of empties) if (wouldCreateDaliIfPlaced(opponent,s)) return s;
  const prefer = [17,9,14,1,22,6,12,4,20,19,11,3,16,8,10,2,0,5,7,13,15,18,21,23];
  for (const p of prefer) if (empties.includes(p)) return p;
  return empties[Math.floor(Math.random()*empties.length)];
}
function aiChooseMove(player, difficulty){
  const opponent = player===1?2:1;
  const moves=[];
  boardState.forEach((v,i)=>{ if (v===player) for (const n of boardMap[i]) if (boardState[n]===0) moves.push([i,n]); });
  if (moves.length===0) return null;
  if (difficulty==='easy') return moves[Math.floor(Math.random()*moves.length)];
  for (const m of moves){
    const [f,t]=m; boardState[f]=0; boardState[t]=player;
    const made = dalis.some(d=>d.includes(t) && boardState[d[0]]===player && boardState[d[1]]===player && boardState[d[2]]===player);
    boardState[f]=player; boardState[t]=0;
    if (made) return m;
  }
  for (const m of moves){
    const [f,t]=m; boardState[f]=0; boardState[t]=player;
    const oppCanWin = (()=> {
      for (let p=0;p<24;p++){
        if (boardState[p]===0){
          boardState[p]=opponent;
          const win = dalis.some(d=>d.includes(p) && boardState[d[0]]===opponent && boardState[d[1]]===opponent && boardState[d[2]]===opponent);
          boardState[p]=0;
          if (win) return true;
        }
      }
      return false;
    })();
    boardState[f]=player; boardState[t]=0;
    if (!oppCanWin) return m;
  }
  if (difficulty==='hard'){
    let best=null; let bestScore=Infinity;
    for (const m of moves){
      const [f,t]=m; boardState[f]=0; boardState[t]=player;
      let oppMoves=0; boardState.forEach((v,i)=>{ if (v===opponent) for (const n of boardMap[i]) if (boardState[n]===0) oppMoves++; });
      boardState[f]=player; boardState[t]=0;
      if (oppMoves < bestScore){ bestScore=oppMoves; best=m; }
    }
    if (best) return best;
  }
  return moves[Math.floor(Math.random()*moves.length)];
}
function aiMakePlacement(player){
  const diff = difficultySelect.value;
  const s = aiChoosePlacement(player, diff);
  if (s===null) return;
  setTimeout(()=>{
    placePiece(s);
    if (checkDali(s)){ gamePhase='removing'; updateUI(); maybeTriggerAI(); return; }
    switchPlayer();
    if (piecesToPlace===0) gamePhase='moving';
    updateUI();
    maybeTriggerAI();
  }, 450 + Math.random()*400);
}
function aiMakeMove(player){
  const diff = difficultySelect.value;
  const m = aiChooseMove(player, diff);
  if (!m) { checkBlocked(); return; }
  const [f,t] = m;
  setTimeout(()=>{
    boardState[f]=0; boardState[t]=player;
    points[f].classList.remove('p1','p2','selected');
    points[t].classList.add(player===1?'p1':'p2');
    playSound('place');
    if (checkDali(t)){ gamePhase='removing'; updateUI(); maybeTriggerAI(); return; }
    removeDaliHighlight();
    switchPlayer();
    if (checkBlocked()) return;
    updateUI();
    maybeTriggerAI();
  }, 420 + Math.random()*380);
}
function aiGivePiece(aiPlayer){
  const ownPieces = boardState.map((v,i)=>v===aiPlayer?i:-1).filter(i=>i!==-1);
  if (ownPieces.length===0) return;
  let candidate=null;
  for (const id of ownPieces){
    const count = dalis.reduce((acc,d)=> d.includes(id) && d.every(p=>boardState[p]===aiPlayer) ? acc+1 : acc ,0);
    if (count===0){ candidate=id; break; }
  }
  if (candidate===null) candidate = ownPieces[Math.floor(Math.random()*ownPieces.length)];
  setTimeout(()=>{
    removePiece(candidate);
    removeDaliHighlight();
    if (checkWin()) return;
    gamePhase = (piecesToPlace===0)?'moving':'placing';
    switchPlayer();
    updateUI();
    maybeTriggerAI();
  }, 600);
}

/* Trigger AI when needed */
function maybeTriggerAI(){
  if (modeSelect.value === 'human-computer'){ humanPlays = {1:true,2:false}; aiPlaysAs=2; }
  else { humanPlays = {1:true,2:true}; aiPlaysAs=null; }
  if (!humanPlays[currentPlayer]){
    if (gamePhase==='placing') aiMakePlacement(currentPlayer);
    else if (gamePhase==='moving') aiMakeMove(currentPlayer);
    else if (gamePhase==='removing'){
      const opponent = currentPlayer===1?2:1;
      const oppPieces = boardState.map((v,i)=>v===opponent?i:-1).filter(i=>i!==-1);
      const nonDali = oppPieces.filter(id=>!isPieceInDali(id,opponent));
      if (nonDali.length>0){
        setTimeout(()=>{ removePiece(nonDali[Math.floor(Math.random()*nonDali.length)]); removeDaliHighlight(); if (checkWin()) return; gamePhase=(piecesToPlace===0)?'moving':'placing'; switchPlayer(); updateUI(); maybeTriggerAI(); }, 500);
      } else {
        const allIn = checkAllPiecesInDalis(opponent);
        if (allIn){
          giveRequester = currentPlayer; giveGiver = opponent; gamePhase='ask_give';
          statusText.textContent = `All Player ${opponent}'s pieces are in Dalis. Player ${opponent}: You must GIVE one piece (click it).`;
          if (!humanPlays[giveGiver]) aiGivePiece(giveGiver);
        } else {
          setTimeout(()=> {
            const candidates = nonDali;
            removePiece(candidates[Math.floor(Math.random()*candidates.length)]);
            removeDaliHighlight();
            if (checkWin()) return;
            gamePhase=(piecesToPlace===0)?'moving':'placing'; switchPlayer(); updateUI(); maybeTriggerAI();
          }, 450);
        }
      }
    } else if (gamePhase==='ask_give'){
      if (!humanPlays[giveGiver]) aiGivePiece(giveGiver);
    }
  }
}

/* =========================
   UI updates, themes & init
   ========================= */
function updateUI(){
  p1CountEl.textContent = player1PieceCount;
  p2CountEl.textContent = player2PieceCount;

  // status text
  if (gamePhase==='placing') statusText.textContent = `Player ${currentPlayer}: Place a piece (${piecesToPlace} left).`;
  else if (gamePhase==='moving') statusText.textContent = `Player ${currentPlayer}: Move a piece.`;
  else if (gamePhase==='removing') statusText.textContent = `Dali! Player ${currentPlayer}: Remove one opponent piece.`;
  else if (gamePhase==='ask_give') statusText.textContent = `Player ${giveGiver}: You must give one of your pieces now.`;

  // compute coin border based on board bg for better contrast
  // read board background from boardEl style or document variable
  let boardColor = getComputedStyle(document.documentElement).getPropertyValue('--board-bg').trim();
  if (!boardColor) boardColor = window.getComputedStyle(boardEl).backgroundColor || '#ffffff';
  // if boardColor is rgb(...) convert to hex helper; else we expect hex
  function rgbToHex(rgb){
    const m = rgb.match(/^rgb\\((\\d+),\\s*(\\d+),\\s*(\\d+)\\)$/);
    if (!m) return rgb;
    return '#'+[1,2,3].map(i=>parseInt(m[i]).toString(16).padStart(2,'0')).join('');
  }
  if (boardColor.startsWith('rgb')) boardColor = rgbToHex(boardColor);
  const coinBorder = computeContrastColor(boardColor);
  document.documentElement.style.setProperty('--coin-border', coinBorder);

  // apply colors & shapes
  document.documentElement.style.setProperty('--p1-color', p1ColorInput.value);
  document.documentElement.style.setProperty('--p2-color', p2ColorInput.value);

  const shape = coinShapeEl.value;
  points.forEach(pt=>{
    pt.classList.remove('circle','square','hex','diamond');
    pt.classList.add(shape);
    if (shape==='diamond'){
      if (pt.classList.contains('selected')) pt.style.transform = 'translate(-50%,-50%) scale(1.18) rotate(45deg)';
      else pt.style.transform = 'translate(-50%,-50%) rotate(45deg)';
    } else {
      pt.style.transform = pt.classList.contains('selected') ? 'translate(-50%,-50%) scale(1.18)' : 'translate(-50%,-50%)';
    }
    if (pt.classList.contains('p1')) pt.style.backgroundColor = p1ColorInput.value;
    else if (pt.classList.contains('p2')) pt.style.backgroundColor = p2ColorInput.value;
    else pt.style.backgroundColor = 'rgba(255,255,255,0.06)';
    // ensure border contrast
    pt.style.borderColor = coinBorder;
  });

  // set board background color
  const boardBg = getComputedStyle(document.documentElement).getPropertyValue('--board-bg').trim() || '#ffffff';
  boardEl.style.backgroundColor = boardBg;
}

/* Clear / New game */
function resetGameState(){
  boardState = new Array(24).fill(0);
  currentPlayer = 1;
  gamePhase = 'placing';
  piecesToPlace = 22;
  player1PieceCount = 11;
  player2PieceCount = 11;
  selectedPiece = null;
  formedDali = null;
  giveRequester = null;
  giveGiver = null;
  lastMoveId = null;
  // hide banner
  winnerBanner.style.display = 'none';
  // reattach click listeners
  points.forEach(pt=>{
    pt.removeEventListener('click', handlePointClick);
    pt.addEventListener('click', handlePointClick);
  });
  // clear visuals
  points.forEach(pt => {
    pt.classList.remove('p1','p2','selected','dali-formed','pop','last-move');
    pt.style.borderColor = getComputedStyle(document.documentElement).getPropertyValue('--coin-border').trim();
  });
  updateUI();
}
function restartGame(){
  resetGameState();
  playSound('select');
}

/* =========================
   Theme handlers
   ========================= */
boardThemeBtns.forEach(btn=>{
  btn.addEventListener('click', ()=> {
    boardThemeBtns.forEach(b=>b.classList.remove('active'));
    btn.classList.add('active');
    const c = btn.dataset.color;
    document.documentElement.style.setProperty('--board-bg', c);
    boardEl.style.backgroundColor = c;
    updateUI();
  });
});
playerThemeBtns.forEach(btn=>{
  btn.addEventListener('click', ()=> {
    playerThemeBtns.forEach(b=>b.classList.remove('active'));
    btn.classList.add('active');
    const p1 = btn.dataset.p1;
    const p2 = btn.dataset.p2;
    p1ColorInput.value = p1;
    p2ColorInput.value = p2;
    document.documentElement.style.setProperty('--p1-color', p1);
    document.documentElement.style.setProperty('--p2-color', p2);
    updateUI();
  });
});
p1ColorInput.addEventListener('input', ()=> { document.documentElement.style.setProperty('--p1-color', p1ColorInput.value); updateUI(); });
p2ColorInput.addEventListener('input', ()=> { document.documentElement.style.setProperty('--p2-color', p2ColorInput.value); updateUI(); });
coinShapeEl.addEventListener('change', updateUI);

/* =========================
   Wire up UI & events
   ========================= */
points.forEach(pt=>pt.addEventListener('click', handlePointClick));
newGameBtn.addEventListener('click', restartGame);
bannerNewGame.addEventListener('click', ()=>{ restartGame(); });
bannerClose.addEventListener('click', ()=>{ winnerBanner.style.display='none'; });

optionsToggle.addEventListener('click', ()=>{
  if (controlsPanel.style.display === 'flex' || controlsPanel.style.display === '') {
    controlsPanel.style.display = 'none';
    optionsToggle.textContent = 'Options ▾';
  } else {
    controlsPanel.style.display = 'flex';
    optionsToggle.textContent = 'Options ▴';
  }
});

// Mode and difficulty listeners
modeSelect.addEventListener('change', ()=>{ if (modeSelect.value === 'human-computer'){ humanPlays={1:true,2:false}; aiPlaysAs=2; } else { humanPlays={1:true,2:true}; aiPlaysAs=null; } maybeTriggerAI(); });
difficultySelect.addEventListener('change', ()=>{/* nothing extra */});

/* =========================
   Preview image generator & download (client-side)
   ========================= */
downloadPreviewBtn.addEventListener('click', ()=> {
  // Build a small SVG preview consistent with the current theme
  const boardBg = getComputedStyle(document.documentElement).getPropertyValue('--board-bg').trim() || '#ffffff';
  const p1 = p1ColorInput.value;
  const p2 = p2ColorInput.value;
  const svg = `
  <svg xmlns="http://www.w3.org/2000/svg" width="1200" height="630">
    <defs>
      <linearGradient id="bg" x1="0" x2="0" y1="0" y2="1">
        <stop offset="0" stop-color="#0b1220"/>
        <stop offset="1" stop-color="#071026"/>
      </linearGradient>
      <filter id="shadow" x="-50%" y="-50%" width="200%" height="200%">
         <feDropShadow dx="0" dy="18" stdDeviation="30" flood-color="#000" flood-opacity="0.6"/>
      </filter>
    </defs>
    <rect width="100%" height="100%" fill="url(#bg)"/>
    <g transform="translate(120,60)" filter="url(#shadow)">
      <rect x="0" y="0" width="960" height="510" rx="8" fill="${boardBg}" stroke="#9fb0c8" stroke-width="4"/>
      <!-- inner lines -->
      <rect x="70" y="50" width="820" height="410" rx="0" fill="none" stroke="#9fb0c8" stroke-width="2"/>
      <rect x="220" y="160" width="520" height="210" rx="0" fill="none" stroke="#9fb0c8" stroke-width="2"/>
      <!-- sample coins -->
      <circle cx="120" cy="120" r="16" fill="${p1}" stroke="${computeContrastColor(boardBg)}" stroke-width="3"/>
      <circle cx="840" cy="390" r="16" fill="${p2}" stroke="${computeContrastColor(boardBg)}" stroke-width="3"/>
    </g>
    <text x="120" y="36" font-family="Inter, Arial" font-size="28" fill="#e6eef8">Dali Puzzle — Play online</text>
  </svg>`;
  // Convert SVG to PNG using canvas
  const svgBlob = new Blob([svg], {type: 'image/svg+xml;charset=utf-8'});
  const url = URL.createObjectURL(svgBlob);
  const img = new Image();
  img.onload = function(){
    const canvas = document.createElement('canvas');
    canvas.width = 1200; canvas.height = 630;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = '#071026';
    ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.drawImage(img,0,0);
    URL.revokeObjectURL(url);
    // download as png
    const png = canvas.toDataURL('image/png');
    const a = document.createElement('a');
    a.href = png;
    a.download = 'preview.png';
    document.body.appendChild(a);
    a.click();
    a.remove();
  };
  img.onerror = ()=>{ alert('Preview generation failed in this browser.'); };
  img.src = url;
});

/* initialize */
(function init(){
  // initial board bg var and coin border
  document.documentElement.style.setProperty('--board-bg', '#ffffff');
  document.documentElement.style.setProperty('--p1-color', p1ColorInput.value);
  document.documentElement.style.setProperty('--p2-color', p2ColorInput.value);
  // compute coin border and set it
  const cb = computeContrastColor('#ffffff');
  document.documentElement.style.setProperty('--coin-border', cb);
  boardEl.style.backgroundColor = '#ffffff';
  resetGameState();
  updateUI();
  statusText.textContent = 'Player 1: Place a piece to start.';
})();
</script>
</body>
</html>
